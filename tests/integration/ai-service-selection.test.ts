/**
 * AI Service Selection and Reliability Integration Tests
 * 
 * Tests the production AI decisions:
 * 1. Which AI service to choose and why (Cost, reliability, medical accuracy)
 * 2. How to handle AI reliability in production (Retries, fallbacks, validation)
 * 
 * These tests validate the core AI production decisions documented in README.md
 */

import { Test, TestingModule } from '@nestjs/testing';
import { ContentEnhancementProcessor } from '../../services/ai-worker/src/processors/content-enhancement.processor';
import { OpenAIProvider } from '../../services/ai-worker/src/providers/openai.provider';
import { AnthropicProvider } from '../../services/ai-worker/src/providers/anthropic.provider';
import { RetryStrategy } from '../../services/ai-worker/src/retry/retry-strategy.ts';

describe('AI Service Selection Strategy', () => {
  let processor: ContentEnhancementProcessor;
  let openaiProvider: jest.Mocked<OpenAIProvider>;
  let anthropicProvider: jest.Mocked<AnthropicProvider>;
  let retryStrategy: RetryStrategy;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ContentEnhancementProcessor,
        {
          provide: OpenAIProvider,
          useValue: {
            generateContent: jest.fn(),
            isHealthy: jest.fn(),
            getCostPerToken: jest.fn(),
            getLatency: jest.fn(),
          },
        },
        {
          provide: AnthropicProvider,
          useValue: {
            generateContent: jest.fn(),
            isHealthy: jest.fn(),
            getCostPerToken: jest.fn(),
            getLatency: jest.fn(),
          },
        },
        RetryStrategy,
      ],
    }).compile();

    processor = module.get<ContentEnhancementProcessor>(ContentEnhancementProcessor);
    openaiProvider = module.get(OpenAIProvider);
    anthropicProvider = module.get(AnthropicProvider);
    retryStrategy = module.get<RetryStrategy>(RetryStrategy);
  });

  describe('Cost-Effectiveness Analysis', () => {
    test('should prioritize GPT-3.5-turbo for cost optimization', async () => {
      // Simulate real-world cost differences
      openaiProvider.getCostPerToken.mockReturnValue(0.0015); // GPT-3.5-turbo actual cost
      anthropicProvider.getCostPerToken.mockReturnValue(0.008); // Claude-3-haiku actual cost

      const costAnalysis = await processor.analyzeCostEffectiveness();

      expect(costAnalysis.primaryProvider).toBe('openai');
      expect(costAnalysis.costRatio).toBeGreaterThan(5); // Anthropic ~5x more expensive
      expect(costAnalysis.recommendation).toBe('Use OpenAI for primary generation, Anthropic for fallback');
    });

    test('should calculate ROI for medical content generation', async () => {
      const mockDrug = createMockDrug('Humira', 'adalimumab');
      
      openaiProvider.generateContent.mockResolvedValue({
        content: 'Humira (Adalimumab) - RA Treatment Information',
        tokensUsed: 150,
        processingTime: 2000,
      });

      const result = await processor.generateSEOTitle(mockDrug);
      const costPerPage = (150 * 0.0015) / 1000; // $0.000225 per page

      expect(costPerPage).toBeLessThan(0.001); // Under $0.001 per page
      expect(result.costEfficiency).toBe('high');
    });
  });

  describe('Reliability and Uptime Testing', () => {
    test('should handle OpenAI service outages gracefully', async () => {
      // Simulate OpenAI 503 Service Unavailable
      openaiProvider.generateContent.mockRejectedValueOnce(
        new Error('503 Service Unavailable - rate limit exceeded')
      );
      
      // Anthropic should be available
      anthropicProvider.generateContent.mockResolvedValue({
        content: 'Reliable fallback content generated by Claude',
        source: 'anthropic',
      });

      const mockDrug = createMockDrug('Advil', 'ibuprofen');
      const result = await processor.generateWithFallback(mockDrug);

      expect(result.source).toBe('anthropic');
      expect(result.content).toContain('Reliable fallback content');
      expect(processor.getCurrentProvider()).toBe('anthropic');
    });

    test('should track and report provider uptime metrics', async () => {
      const uptimeTracker = processor.getUptimeTracker();
      
      // Simulate 24 hours of API calls
      for (let hour = 0; hour < 24; hour++) {
        for (let call = 0; call < 10; call++) {
          try {
            if (hour === 14 && call < 3) {
              // Simulate 3 failures during peak hours
              throw new Error('Rate limit exceeded');
            }
            await processor.makeTestAPICall('openai');
            uptimeTracker.recordSuccess('openai');
          } catch (error) {
            uptimeTracker.recordFailure('openai', error.message);
          }
        }
      }

      const metrics = uptimeTracker.getMetrics('openai');
      expect(metrics.uptime).toBeGreaterThan(0.98); // 98%+ uptime required
      expect(metrics.totalCalls).toBe(240);
      expect(metrics.failureRate).toBeLessThan(0.02); // < 2% failure rate
    });

    test('should validate 99.9% uptime SLA requirements', async () => {
      const slaValidator = processor.getSLAValidator();
      
      // Test against production SLA requirements
      const slaRequirements = {
        openai: { uptime: 0.999, maxLatency: 5000 },
        anthropic: { uptime: 0.995, maxLatency: 8000 },
      };

      const results = await slaValidator.validateSLA(slaRequirements, {
        testDuration: '1h',
        callFrequency: 100, // 100 calls per hour
      });

      expect(results.openai.meetsUptime).toBe(true);
      expect(results.anthropic.meetsUptime).toBe(true);
      expect(results.overallReliability).toBeGreaterThan(0.999);
    });
  });

  describe('Medical Accuracy Benchmarking', () => {
    test('should compare AI providers for medical content accuracy', async () => {
      const medicalBenchmark = processor.getMedicalBenchmark();
      
      const testCases = [
        {
          drug: 'Tylenol',
          generic: 'acetaminophen',
          indication: 'pain relief',
          expectedKeywords: ['acetaminophen', 'pain', 'fever', 'OTC'],
        },
        {
          drug: 'Lipitor',
          generic: 'atorvastatin',
          indication: 'cholesterol management',
          expectedKeywords: ['atorvastatin', 'cholesterol', 'statin', 'cardiovascular'],
        },
      ];

      const results = await medicalBenchmark.compareProviders(testCases);

      expect(results.openai.medicalAccuracy).toBeGreaterThan(0.85);
      expect(results.anthropic.medicalAccuracy).toBeGreaterThan(0.85);
      expect(results.recommendation).toMatch(/primary|fallback/);
    });

    test('should validate consistency of medical terminology', async () => {
      const drug = createMockDrug('Prozac', 'fluoxetine');
      
      // Generate same content 5 times to test consistency
      const results = await Promise.all([
        processor.generateSEOTitle(drug),
        processor.generateSEOTitle(drug),
        processor.generateSEOTitle(drug),
        processor.generateSEOTitle(drug),
        processor.generateSEOTitle(drug),
      ]);

      // All results should contain consistent medical terms
      const medicalTerms = ['fluoxetine', 'Prozac', 'depression'];
      results.forEach(result => {
        medicalTerms.forEach(term => {
          expect(result.content.toLowerCase()).toContain(term.toLowerCase());
        });
      });

      // Validate consistency score
      const consistencyScore = calculateConsistency(results);
      expect(consistencyScore).toBeGreaterThan(0.8); // 80% consistency required
    });
  });

  describe('Performance and Response Time Analysis', () => {
    test('should meet sub-5s response time requirements', async () => {
      const startTime = Date.now();
      
      const mockDrug = createMockDrug('Aspirin', 'acetylsalicylic acid');
      await processor.generateSEOTitle(mockDrug);
      
      const responseTime = Date.now() - startTime;
      expect(responseTime).toBeLessThan(5000); // < 5 seconds
    });

    test('should track and optimize token usage', async () => {
      const tokenTracker = processor.getTokenTracker();
      
      const testPrompts = [
        'Generate SEO title for diabetes medication',
        'Create meta description for heart medication',
        'Generate FAQ for pain relief drug',
      ];

      for (const prompt of testPrompts) {
        const result = await processor.generateContent(prompt);
        tokenTracker.record(result.tokensUsed, prompt.length);
      }

      const efficiency = tokenTracker.getEfficiency();
      expect(efficiency.averageTokensPerCharacter).toBeLessThan(2); // Efficient prompting
      expect(efficiency.costPerGeneration).toBeLessThan(0.01); // < $0.01 per generation
    });
  });

  describe('Production Decision Validation', () => {
    test('should justify primary provider selection (OpenAI)', async () => {
      const decisionMatrix = processor.getProviderDecisionMatrix();
      
      const criteria = {
        cost: { weight: 0.3, openai: 9, anthropic: 6 },
        reliability: { weight: 0.25, openai: 8, anthropic: 8 },
        medicalAccuracy: { weight: 0.25, openai: 8, anthropic: 9 },
        speed: { weight: 0.2, openai: 9, anthropic: 7 },
      };

      const scores = decisionMatrix.calculate(criteria);
      
      expect(scores.openai).toBeGreaterThan(scores.anthropic);
      expect(decisionMatrix.recommendation).toBe('openai-primary-anthropic-fallback');
    });

    test('should validate dual-provider architecture benefits', async () => {
      const architectureValidator = processor.getArchitectureValidator();
      
      // Test single vs dual provider resilience
      const singleProviderUptime = await architectureValidator.simulateUptime({
        providers: ['openai'],
        duration: '30d',
        failures: [
          { day: 5, duration: '2h', reason: 'maintenance' },
          { day: 18, duration: '45m', reason: 'rate_limit' },
        ],
      });

      const dualProviderUptime = await architectureValidator.simulateUptime({
        providers: ['openai', 'anthropic'],
        duration: '30d',
        failures: [
          { day: 5, duration: '2h', reason: 'maintenance', provider: 'openai' },
          { day: 18, duration: '45m', reason: 'rate_limit', provider: 'openai' },
        ],
      });

      expect(dualProviderUptime).toBeGreaterThan(singleProviderUptime);
      expect(dualProviderUptime).toBeGreaterThan(0.999); // 99.9%+ with dual providers
    });
  });
});

// Helper functions
function createMockDrug(brandName: string, genericName: string) {
  return {
    id: 'test-drug-id',
    brandName,
    genericName,
    manufacturer: 'Test Pharma',
    indications: ['Test condition'],
    slug: brandName.toLowerCase(),
  };
}

function calculateConsistency(results: any[]): number {
  const terms = results.map(r => r.content.toLowerCase().split(/\s+/));
  const commonTerms = terms[0].filter(term => 
    terms.every(termList => termList.includes(term))
  );
  return commonTerms.length / terms[0].length;
}